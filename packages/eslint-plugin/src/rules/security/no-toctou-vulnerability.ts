/**
 * ESLint Rule: no-toctou-vulnerability
 * Detects Time-of-Check-Time-of-Use vulnerabilities
 * CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition
 * 
 * @see https://cwe.mitre.org/data/definitions/367.html
 * @see https://owasp.org/www-community/vulnerabilities/TOCTOU_Race_Condition
 */
import type { TSESLint, TSESTree } from '@forge-js/eslint-plugin-utils';
import { formatLLMMessage, MessageIcons } from '@forge-js/eslint-plugin-utils';
import { createRule } from '@forge-js/eslint-plugin-utils';

type MessageIds =
  | 'toctouVulnerability'
  | 'useAtomicOperations'
  | 'useFsPromises'
  | 'addProperLocking';

export interface Options {
  /** Ignore in test files. Default: true */
  ignoreInTests?: boolean;
  
  /** File system methods to check. Default: ['fs.existsSync', 'fs.statSync', 'fs.accessSync'] */
  fsMethods?: string[];
}

type RuleOptions = [Options?];

export const noToctouVulnerability = createRule<RuleOptions, MessageIds>({
  name: 'no-toctou-vulnerability',
  meta: {
    type: 'problem',
    docs: {
      description: 'Detects Time-of-Check-Time-of-Use vulnerabilities',
    },
    hasSuggestions: true,
    messages: {
      toctouVulnerability: formatLLMMessage({
        icon: MessageIcons.SECURITY,
        issueName: 'TOCTOU vulnerability',
        cwe: 'CWE-367',
        description: 'Time-of-check Time-of-use race condition detected',
        severity: 'HIGH',
        fix: 'Use atomic operations or fs.promises for file operations',
        documentationLink: 'https://cwe.mitre.org/data/definitions/367.html',
      }),
      useAtomicOperations: formatLLMMessage({
        icon: MessageIcons.INFO,
        issueName: 'Use Atomic Operations',
        description: 'Use atomic file operations',
        severity: 'LOW',
        fix: 'fs.promises.access() then fs.promises.readFile()',
        documentationLink: 'https://nodejs.org/api/fs.html#fspromisesaccesspath-mode',
      }),
      useFsPromises: formatLLMMessage({
        icon: MessageIcons.INFO,
        issueName: 'Use fs.promises',
        description: 'Use fs.promises API',
        severity: 'LOW',
        fix: 'await fs.promises.readFile() instead of sync operations',
        documentationLink: 'https://nodejs.org/api/fs.html#promises-api',
      }),
      addProperLocking: formatLLMMessage({
        icon: MessageIcons.INFO,
        issueName: 'Add File Locking',
        description: 'Add proper locking mechanism',
        severity: 'LOW',
        fix: 'Use proper-lockfile or similar for concurrent access',
        documentationLink: 'https://github.com/moxystudio/node-proper-lockfile',
      }),
    },
    schema: [
      {
        type: 'object',
        properties: {
          ignoreInTests: {
            type: 'boolean',
            default: true,
          },
          fsMethods: {
            type: 'array',
            items: { type: 'string' },
            default: ['fs.existsSync', 'fs.statSync', 'fs.accessSync'],
          },
        },
        additionalProperties: false,
      },
    ],
  },
  defaultOptions: [
    {
      ignoreInTests: true,
      fsMethods: ['fs.existsSync', 'fs.statSync', 'fs.accessSync'],
    },
  ],
  create(context: TSESLint.RuleContext<MessageIds, RuleOptions>, [options = {}]) {
    const {
ignoreInTests = true 
}: Options = options || {};

    const filename = context.getFilename();
    const isTestFile = ignoreInTests && /\.(test|spec)\.(ts|tsx|js|jsx)$/.test(filename);

    if (isTestFile) {
      return {};
    }

    const sourceCode = context.sourceCode || context.sourceCode;

    /**
     * Check for TOCTOU patterns
     */
    function checkCallExpression(node: TSESTree.CallExpression) {
      const nodeText = sourceCode.getText(node);

      // Only flag file operations (not checks) that are part of check-then-use patterns
      if (!/\b(fs\.readFileSync|fs\.writeFileSync|fs\.openSync|fs\.unlinkSync)\s*\(/.test(nodeText)) {
        return; // Not a file operation we care about
      }

      // Check if this operation is inside an if statement that contains a file check
      let current: TSESTree.Node | undefined = node.parent;
      while (current) {
        if (current.type === 'IfStatement') {
          // Check if the test (condition) contains a file check
          const test = current.test;
          if (test.type === 'CallExpression') {
            const testText = sourceCode.getText(test);
            if (/\b(fs\.existsSync|fs\.statSync|fs\.accessSync)\s*\(/.test(testText)) {
              // Check if the file paths match
              const testCall = test;
              const currentCall = node;

              if (testCall.arguments.length > 0 && currentCall.arguments.length > 0) {
                const testArg = testCall.arguments[0];
                const currentArg = currentCall.arguments[0];

                if (testArg.type === 'Literal' && currentArg.type === 'Literal' &&
                    testArg.value === currentArg.value) {
                  context.report({
                    node,
                    messageId: 'toctouVulnerability',
                    suggest: [
                      {
                        messageId: 'useAtomicOperations',
                        fix: () => null,
                      },
                      {
                        messageId: 'useFsPromises',
                        fix: () => null,
                      },
                      {
                        messageId: 'addProperLocking',
                        fix: () => null,
                      },
                    ],
                  });
                  return; // Found a match, stop searching
                }
              }
            }
          }

          // Also check for stat-then-use patterns
          if (test.type === 'CallExpression' || test.type === 'MemberExpression') {
            const testText = sourceCode.getText(test);

            // Pattern: if (stats.isFile()) { ... fs.unlinkSync("file") ... }
            if (testText.includes('isFile') && nodeText.includes('fs.unlinkSync')) {
              context.report({
                node,
                messageId: 'toctouVulnerability',
                suggest: [
                  {
                    messageId: 'useAtomicOperations',
                    fix: () => null,
                  },
                  {
                    messageId: 'useFsPromises',
                    fix: () => null,
                  },
                  {
                    messageId: 'addProperLocking',
                    fix: () => null,
                  },
                ],
              });
              return; // Found a match, stop searching
            }
          }
        }
        current = current.parent as TSESTree.Node;
      }
    }

    return {
      CallExpression: checkCallExpression,
    };
  },
});

