/**
 * ESLint Rule: no-toctou-vulnerability
 * Detects Time-of-Check-Time-of-Use vulnerabilities
 * CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition
 * 
 * @see https://cwe.mitre.org/data/definitions/367.html
 * @see https://owasp.org/www-community/vulnerabilities/TOCTOU_Race_Condition
 */
import type { TSESLint, TSESTree } from '@forge-js/eslint-plugin-utils';
import { formatLLMMessage, MessageIcons } from '@forge-js/eslint-plugin-utils';
import { createRule } from '../../utils/create-rule';

type MessageIds =
  | 'toctouVulnerability'
  | 'useAtomicOperations'
  | 'useFsPromises'
  | 'addProperLocking';

export interface Options {
  /** Ignore in test files. Default: true */
  ignoreInTests?: boolean;
  
  /** File system methods to check. Default: ['fs.existsSync', 'fs.statSync', 'fs.accessSync'] */
  fsMethods?: string[];
}

type RuleOptions = [Options?];

export const noToctouVulnerability = createRule<RuleOptions, MessageIds>({
  name: 'no-toctou-vulnerability',
  meta: {
    type: 'problem',
    docs: {
      description: 'Detects Time-of-Check-Time-of-Use vulnerabilities',
    },
    hasSuggestions: true,
    messages: {
      toctouVulnerability: formatLLMMessage({
        icon: MessageIcons.SECURITY,
        issueName: 'TOCTOU vulnerability',
        cwe: 'CWE-367',
        description: 'Time-of-check Time-of-use race condition detected',
        severity: 'HIGH',
        fix: 'Use atomic operations or fs.promises for file operations',
        documentationLink: 'https://cwe.mitre.org/data/definitions/367.html',
      }),
      useAtomicOperations: '✅ Use atomic operations: fs.promises.access() then fs.promises.readFile()',
      useFsPromises: '✅ Use fs.promises: await fs.promises.readFile() instead of sync operations',
      addProperLocking: '✅ Add proper locking mechanism for concurrent file access',
    },
    schema: [
      {
        type: 'object',
        properties: {
          ignoreInTests: {
            type: 'boolean',
            default: true,
          },
          fsMethods: {
            type: 'array',
            items: { type: 'string' },
            default: ['fs.existsSync', 'fs.statSync', 'fs.accessSync'],
          },
        },
        additionalProperties: false,
      },
    ],
  },
  defaultOptions: [
    {
      ignoreInTests: true,
      fsMethods: ['fs.existsSync', 'fs.statSync', 'fs.accessSync'],
    },
  ],
  create(context: TSESLint.RuleContext<MessageIds, RuleOptions>, [options = {}]) {
    const {
ignoreInTests = true 
}: Options = options || {};

    const filename = context.getFilename();
    const isTestFile = ignoreInTests && /\.(test|spec)\.(ts|tsx|js|jsx)$/.test(filename);

    if (isTestFile) {
      return {};
    }

    const sourceCode = context.sourceCode || context.getSourceCode();

    /**
     * Check for TOCTOU patterns
     */
    function checkCallExpression(node: TSESTree.CallExpression) {
      const callText = sourceCode.getText(node);
      
      // Check for file existence/stat checks
      if (/\b(fs\.existsSync|fs\.statSync|fs\.accessSync)\s*\(/.test(callText)) {
        // Find subsequent file operations in the same scope
        // This is simplified - would need proper control flow analysis
      }
      
      // Check for file operations that might be vulnerable
      if (/\b(fs\.readFileSync|fs\.writeFileSync|fs\.openSync|fs\.unlinkSync)\s*\(/.test(callText)) {
        // Check if preceded by a check operation
        // Simplified check - would need proper analysis
        context.report({
          node,
          messageId: 'toctouVulnerability',
          suggest: [
            {
              messageId: 'useAtomicOperations',
              fix: () => null,
            },
            {
              messageId: 'useFsPromises',
              fix: () => null,
            },
            {
              messageId: 'addProperLocking',
              fix: () => null,
            },
          ],
        });
      }
    }

    return {
      CallExpression: checkCallExpression,
    };
  },
});

