# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Release Unscoped Packages

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WORKFLOW PURPOSE: Publish UNscoped packages (eslint-plugin-*) only
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# Packages handled by this workflow:
#   - eslint-plugin-llm (project: eslint-plugin-llm)
#   - eslint-plugin-mcp (project: eslint-plugin-mcp)
#   - eslint-plugin-llm-optimized (project: eslint-plugin-llm-optimized)
#   - eslint-plugin-mcp-optimized (project: eslint-plugin-mcp-optimized)
#
# Authentication: NPM_TOKEN (Granular Access Token) via .npmrc
# Scope: NONE (unscoped packages)
#
# For SCOPED packages (@forge-js/*), use: release.yml
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

on:
  workflow_dispatch:
    inputs:
      version-specifier:
        description: "Version bump strategy (auto = conventional commits)"
        required: false
        type: choice
        options:
          [auto, major, minor, patch, premajor, preminor, prepatch, prerelease]
        default: "auto"
      dist-tag:
        description: "NPM distribution tag"
        required: false
        type: choice
        options: [latest, next, beta, rc, alpha, canary]
        default: "latest"
      dry-run:
        description: "Dry run: preview changes without modifying git or NPM"
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  NODE_VERSION: "20"
  PNPM_VERSION: "10.18.3"

jobs:
  release-unscoped:
    name: ðŸš€ Release Unscoped Packages
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 15
    permissions:
      contents: write
      id-token: none # Not needed for unscoped packages (using NPM_TOKEN)
      pull-requests: write

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: main

      - name: âš™ï¸ Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: âš™ï¸ Setup Node.js (NPM_TOKEN for Unscoped)
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: https://registry.npmjs.org/
          cache: "pnpm"
          # NO scope set - unscoped packages use NPM_TOKEN (Granular Access Token)
          # This ensures unscoped packages don't try to use Trusted Publishing

      - name: ðŸ“¦ Install dependencies
        run: pnpm install --frozen-lockfile

      - name: ðŸ”— Configure Nx Cloud (Optional)
        continue-on-error: true
        run: |
          if [ -n "${{ secrets.NX_CLOUD_ACCESS_TOKEN }}" ]; then
            echo "ðŸ”— Connecting to Nx Cloud..."
            if npx nx connect-to-nx-cloud --quiet --no-interactive; then
              echo "âœ… Nx Cloud connected successfully"
            else
              echo "âš ï¸  Nx Cloud connection failed, using local cache only"
              echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
            fi
          else
            echo "â„¹ï¸  NX_CLOUD_ACCESS_TOKEN not set, using local cache only"
            echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
          fi
        env:
          NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN }}

      - name: ðŸ” Verify NPM_TOKEN
        if: inputs.dry-run == false
        run: |
          if [ -z "${{ secrets.NPM_TOKEN }}" ]; then
            echo "âŒ NPM_TOKEN not found"
            echo "   Generate Granular Access Token at: https://www.npmjs.com/settings/[username]/tokens"
            echo "   Add as GitHub secret: gh secret set NPM_TOKEN"
            exit 1
          fi
          echo "âœ… NPM_TOKEN found (Granular Access Token)"

      - name: ðŸ” Configure npm Authentication
        if: inputs.dry-run == false
        run: |
          echo "ðŸ” Configuring npm authentication for unscoped packages..."

          # Configure .npmrc with NPM_TOKEN for unscoped packages
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" >> .npmrc

          echo "âœ… NPM_TOKEN configured in .npmrc"

      - name: ðŸ“ Prepare Release Version (Unscoped Only)
        if: inputs.dry-run == false
        run: |
          git config user.name "Ofri Peretz"
          git config user.email "ofriperetzdev@gmail.com"

          # Explicit list of unscoped packages
          UNSCOPED_PROJECTS="eslint-plugin-llm,eslint-plugin-mcp,eslint-plugin-llm-optimized,eslint-plugin-mcp-optimized"

          # Get affected projects and filter to only unscoped packages
          echo "ðŸ” Detecting affected unscoped packages..."
          AFFECTED_PROJECTS=$(pnpm nx show projects --affected --base=HEAD~1 2>/dev/null | grep -E "^($(echo $UNSCOPED_PROJECTS | tr ',' '|'))$" | tr '\n' ',' | sed 's/,$//' || echo "")

          if [ -z "$AFFECTED_PROJECTS" ]; then
            echo "â„¹ï¸  No affected unscoped packages detected"
            echo "   Checking all unscoped packages for changes..."
            # Fallback: check if any unscoped project has changes
            for PROJECT in $(echo $UNSCOPED_PROJECTS | tr ',' ' '); do
              if git diff --quiet HEAD~1 HEAD -- "packages/$PROJECT" 2>/dev/null; then
                echo "   - $PROJECT: no changes"
              else
                echo "   - $PROJECT: has changes"
                if [ -z "$AFFECTED_PROJECTS" ]; then
                  AFFECTED_PROJECTS="$PROJECT"
                else
                  AFFECTED_PROJECTS="$AFFECTED_PROJECTS,$PROJECT"
                fi
              fi
            done
          fi

          if [ -z "$AFFECTED_PROJECTS" ]; then
            echo "âœ… No unscoped packages have changes - nothing to release"
            exit 0
          fi

          echo "ðŸ“¦ Affected UNscoped packages: $AFFECTED_PROJECTS"
          echo "   (filtered from explicit list: $UNSCOPED_PROJECTS)"
          echo ""

          # Function to run version command with Nx Cloud error handling
          run_version_command() {
            if [ "${{ inputs.version-specifier }}" != "auto" ]; then
              echo "ðŸ“ Using version strategy: ${{ inputs.version-specifier }}"
              VERSION_CMD="pnpm nx release version ${{ inputs.version-specifier }} --projects=$AFFECTED_PROJECTS"
            else
              echo "ðŸ“ Using conventional commits to determine version"
              VERSION_CMD="pnpm nx release version --projects=$AFFECTED_PROJECTS"
            fi
            
            # First attempt with Nx Cloud (if enabled)
            set +e  # Don't exit on error - we'll handle it
            eval "$VERSION_CMD" 2>&1 | tee /tmp/nx-release-output.log
            VERSION_EXIT=${PIPESTATUS[0]}
            set -e  # Re-enable exit on error
            
            # If command failed, check if it's Nx Cloud related
            if [ "$VERSION_EXIT" -ne 0 ]; then
              # Check for any Nx Cloud related errors (quota, connection, auth, etc.)
              if grep -qiE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection.*failed|authentication.*failed|unauthorized|NX_CLOUD.*quota|rate.*limit.*exceeded|429.*Too Many Requests)" /tmp/nx-release-output.log; then
                echo ""
                echo "âš ï¸  Nx Cloud error detected - disabling Nx Cloud and retrying..."
                echo "   Error details:"
                grep -iE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection|authentication|unauthorized|NX_CLOUD)" /tmp/nx-release-output.log | head -5 || true
                echo ""
                echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
                export NX_SKIP_NX_CLOUD=true
                
                # Retry without Nx Cloud - this should succeed
                echo "ðŸ“ Retrying version command without Nx Cloud (using local cache only)..."
                set +e  # Don't exit on error for retry
                eval "$VERSION_CMD"
                RETRY_EXIT=$?  # Capture exit code (no pipe in retry)
                set -e
                
                if [ "$RETRY_EXIT" -ne 0 ]; then
                  echo "âŒ Version command failed even without Nx Cloud - this is a real error"
                  exit $RETRY_EXIT
                else
                  echo "âœ… Version command succeeded without Nx Cloud"
                fi
              else
                # Not an Nx Cloud error - this is a real error
                echo "âŒ Version command failed with non-Nx Cloud error - exiting"
                exit $VERSION_EXIT
              fi
            else
              echo "âœ… Version command succeeded with Nx Cloud"
            fi
          }

          run_version_command
          
          # Cleanup temporary log files
          rm -f /tmp/nx-release-output.log 2>/dev/null || true
        env:
          # Skip Nx Cloud if connection failed or token not set (falls back to local cache)
          NX_SKIP_NX_CLOUD: ${{ env.NX_SKIP_NX_CLOUD || 'false' }}

      - name: ðŸš€ Publish Unscoped Packages
        if: inputs.dry-run == false
        run: |
          echo "ðŸš€ Publishing UNscoped packages with NPM_TOKEN (Granular Access Token)"
          echo ""

          git config user.name "Ofri Peretz"
          git config user.email "ofriperetzdev@gmail.com"

          # Explicit list of unscoped packages
          UNSCOPED_PROJECTS="eslint-plugin-llm,eslint-plugin-mcp,eslint-plugin-llm-optimized,eslint-plugin-mcp-optimized"

          # Get affected projects and filter to only unscoped packages
          echo "ðŸ” Detecting affected unscoped packages for publishing..."
          AFFECTED_PROJECTS=$(pnpm nx show projects --affected --base=HEAD~1 2>/dev/null | grep -E "^($(echo $UNSCOPED_PROJECTS | tr ',' '|'))$" | tr '\n' ',' | sed 's/,$//' || echo "")

          if [ -z "$AFFECTED_PROJECTS" ]; then
            echo "â„¹ï¸  No affected unscoped packages detected"
            echo "   Checking for packages with new tags (from version step)..."
            # Check for packages that have new tags (created in version step)
            for PROJECT in $(echo $UNSCOPED_PROJECTS | tr ',' ' '); do
              # Check if there's a new tag for this project
              LATEST_TAG=$(git tag --sort=-version:refname | grep "^${PROJECT}@" | head -n 1)
              if [ -n "$LATEST_TAG" ]; then
                # Check if tag is new (not in remote or different from previous)
                if [ -z "$AFFECTED_PROJECTS" ]; then
                  AFFECTED_PROJECTS="$PROJECT"
                else
                  AFFECTED_PROJECTS="$AFFECTED_PROJECTS,$PROJECT"
                fi
                echo "   - $PROJECT: has new tag $LATEST_TAG"
              fi
            done
          fi

          if [ -z "$AFFECTED_PROJECTS" ]; then
            echo "âœ… No unscoped packages to publish - nothing was versioned"
            exit 0
          fi

          echo "ðŸ“¦ Publishing affected UNscoped packages: $AFFECTED_PROJECTS"
          echo "   (filtered from explicit list: $UNSCOPED_PROJECTS)"
          echo ""

          # Function to run publish command with Nx Cloud error handling
          run_publish_command() {
            PUBLISH_CMD="pnpm nx release publish --tag ${{ inputs.dist-tag }} --projects=$AFFECTED_PROJECTS"
            
            # First attempt with Nx Cloud (if enabled)
            set +e  # Don't exit on error - we'll handle it
            eval "$PUBLISH_CMD" 2>&1 | tee /tmp/publish-output.log
            PUBLISH_EXIT=${PIPESTATUS[0]}
            set -e  # Re-enable exit on error
            
            # If command failed, check if it's Nx Cloud related
            if [ "$PUBLISH_EXIT" -ne 0 ]; then
              # Check for any Nx Cloud related errors (quota, connection, auth, etc.)
              if grep -qiE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection.*failed|authentication.*failed|unauthorized|NX_CLOUD.*quota|rate.*limit.*exceeded|429.*Too Many Requests)" /tmp/publish-output.log; then
                echo ""
                echo "âš ï¸  Nx Cloud error detected - disabling Nx Cloud and retrying..."
                echo "   Error details:"
                grep -iE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection|authentication|unauthorized|NX_CLOUD)" /tmp/publish-output.log | head -5 || true
                echo ""
                echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
                export NX_SKIP_NX_CLOUD=true
                
                # Retry without Nx Cloud - this should succeed
                echo "ðŸš€ Retrying publish command without Nx Cloud (using local cache only)..."
                set +e  # Don't exit on error for retry
                eval "$PUBLISH_CMD"
                RETRY_EXIT=$?  # Capture exit code (no pipe in retry)
                set -e
                
                if [ "$RETRY_EXIT" -ne 0 ]; then
                  echo "âŒ Publish failed even without Nx Cloud - this is a real error"
                  exit $RETRY_EXIT
                else
                  echo "âœ… Publish succeeded without Nx Cloud"
                fi
              else
                # Not an Nx Cloud error - this is a real error
                echo "âŒ Publish failed with non-Nx Cloud error - exiting"
                exit $PUBLISH_EXIT
              fi
            else
              echo "âœ… Publish succeeded with Nx Cloud"
            fi
          }

          run_publish_command
          
          # Cleanup temporary log files
          rm -f /tmp/publish-output.log 2>/dev/null || true
        env:
          NPM_CONFIG_PROVENANCE: true
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # NPM_TOKEN is configured in .npmrc in previous step
          # Skip Nx Cloud if connection failed or token not set (falls back to local cache)
          NX_SKIP_NX_CLOUD: ${{ env.NX_SKIP_NX_CLOUD || 'false' }}

      - name: ðŸ” Dry Run Preview
        if: inputs.dry-run == true
        run: |
          echo "ðŸ” DRY RUN: Previewing UNscoped package releases"
          echo ""

          # Explicit list of unscoped packages
          UNSCOPED_PROJECTS="eslint-plugin-llm,eslint-plugin-mcp,eslint-plugin-llm-optimized,eslint-plugin-mcp-optimized"

          # Get affected projects and filter to only unscoped packages
          echo "ðŸ” Detecting affected unscoped packages for dry-run..."
          AFFECTED_PROJECTS=$(pnpm nx show projects --affected --base=HEAD~1 2>/dev/null | grep -E "^($(echo $UNSCOPED_PROJECTS | tr ',' '|'))$" | tr '\n' ',' | sed 's/,$//' || echo "")

          if [ -z "$AFFECTED_PROJECTS" ]; then
            echo "â„¹ï¸  No affected unscoped packages detected - will preview all unscoped packages"
            AFFECTED_PROJECTS="$UNSCOPED_PROJECTS"
          fi

          echo "ðŸ“¦ DRY RUN: Previewing affected UNscoped packages: $AFFECTED_PROJECTS"
          echo "   (filtered from explicit list: $UNSCOPED_PROJECTS)"
          echo ""

          # Function to run dry-run version command with Nx Cloud error handling
          run_dry_run_version() {
            if [ "${{ inputs.version-specifier }}" != "auto" ]; then
              echo "ðŸ“ Previewing version strategy: ${{ inputs.version-specifier }}"
              VERSION_CMD="pnpm nx release version ${{ inputs.version-specifier }} --projects=$AFFECTED_PROJECTS --dry-run"
            else
              echo "ðŸ“ Previewing conventional commits version"
              VERSION_CMD="pnpm nx release version --projects=$AFFECTED_PROJECTS --dry-run"
            fi
            
            # First attempt with Nx Cloud (if enabled)
            set +e  # Don't exit on error - we'll handle it
            eval "$VERSION_CMD" 2>&1 | tee /tmp/dry-run-output.log
            VERSION_EXIT=${PIPESTATUS[0]}
            set -e  # Re-enable exit on error
            
            # If command failed, check if it's Nx Cloud related
            if [ "$VERSION_EXIT" -ne 0 ]; then
              # Check for any Nx Cloud related errors (quota, connection, auth, etc.)
              if grep -qiE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection.*failed|authentication.*failed|unauthorized|NX_CLOUD.*quota|rate.*limit.*exceeded|429.*Too Many Requests)" /tmp/dry-run-output.log; then
                echo ""
                echo "âš ï¸  Nx Cloud error detected - disabling Nx Cloud and retrying..."
                echo "   Error details:"
                grep -iE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection|authentication|unauthorized|NX_CLOUD)" /tmp/dry-run-output.log | head -5 || true
                echo ""
                echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
                export NX_SKIP_NX_CLOUD=true
                
                # Retry without Nx Cloud - this should succeed
                echo "ðŸ“ Retrying dry-run version command without Nx Cloud (using local cache only)..."
                set +e  # Don't exit on error for retry
                eval "$VERSION_CMD"
                RETRY_EXIT=$?  # Capture exit code (no pipe in retry)
                set -e
                
                if [ "$RETRY_EXIT" -ne 0 ]; then
                  echo "âŒ Dry-run failed even without Nx Cloud - this is a real error"
                  exit $RETRY_EXIT
                else
                  echo "âœ… Dry-run succeeded without Nx Cloud"
                fi
              else
                # Not an Nx Cloud error - this is a real error
                echo "âŒ Dry-run failed with non-Nx Cloud error - exiting"
                exit $VERSION_EXIT
              fi
            else
              echo "âœ… Dry-run succeeded with Nx Cloud"
            fi
          }

          run_dry_run_version
          
          # Cleanup temporary log files
          rm -f /tmp/dry-run-output.log 2>/dev/null || true
        env:
          # Skip Nx Cloud if connection failed or token not set (falls back to local cache)
          NX_SKIP_NX_CLOUD: ${{ env.NX_SKIP_NX_CLOUD || 'false' }}
