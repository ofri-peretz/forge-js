# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Release Scoped Packages

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# WORKFLOW PURPOSE: Publish SCOPED packages (@forge-js/*) only
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#
# Packages handled by this workflow:
#   - @forge-js/eslint-plugin-llm-optimized (project: eslint-plugin)
#   - @forge-js/eslint-plugin-utils (project: eslint-plugin-utils)
#   - @forge-js/cli (project: cli)
#
# Authentication: Trusted Publishing (OIDC) via NODE_AUTH_TOKEN
# Scope: @forge-js (configured in setup-node@v6)
#
# For UNscoped packages, use: release-unscoped.yml
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

on:
  workflow_dispatch:
    inputs:
      # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      # VERSION STRATEGY
      # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      version-specifier:
        description: "Version bump strategy (auto = conventional commits)"
        required: false
        type: choice
        options:
          - auto
          - major
          - minor
          - patch
          - premajor
          - preminor
          - prepatch
          - prerelease
        default: "auto"

      # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      # NPM PUBLISHING OPTIONS
      # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      dist-tag:
        description: "NPM distribution tag"
        required: false
        type: choice
        options:
          - latest
          - next
          - beta
          - rc
          - alpha
          - canary
        default: "latest"

      # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      # CONTROL FLOW OPTIONS
      # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      run-ci:
        description: "Run CI validation before publishing (slows down release)"
        required: false
        type: boolean
        default: true

      dry-run:
        description: "Dry run: preview changes without modifying git or NPM"
        required: false
        type: boolean
        default: false

# Prevent concurrent releases
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# GLOBAL ENVIRONMENT VARIABLES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
env:
  NODE_VERSION: "20"
  PNPM_VERSION: "10.18.3"

jobs:
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # STEP 1: CI VALIDATION (Optional, skippable)
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  validate-ci:
    name: ‚úÖ CI Validation
    runs-on: ubuntu-latest
    if: inputs.run-ci == true
    timeout-minutes: 15
    permissions:
      contents: read
      id-token: none

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          fetch-tags: true # Fetch tags for completeness (though not strictly needed for CI validation)

      - name: ‚öôÔ∏è Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: ‚öôÔ∏è Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: üì¶ Install dependencies
        run: pnpm install --frozen-lockfile

      - name: üîç Print Environment Info
        run: pnpm nx report

      - name: üß™ Test all packages
        run: |
          # Function to run test with error handling for Nx Cloud failures
          run_test() {
            TEST_CMD="pnpm nx run-many -t test --all -c ci --parallel=4 --verbose"
            
            # First attempt with Nx Cloud (if enabled)
            set +e  # Don't exit on error - we'll handle it
            eval "$TEST_CMD" 2>&1 | tee /tmp/test-output.log
            TEST_EXIT=${PIPESTATUS[0]}
            set -e  # Re-enable exit on error
            
            # If command failed, check if it's Nx Cloud related
            if [ "$TEST_EXIT" -ne 0 ]; then
              # Check for any Nx Cloud related errors (quota, connection, auth, etc.)
              if grep -qiE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection.*failed|authentication.*failed|unauthorized|NX_CLOUD.*quota|rate.*limit.*exceeded|429.*Too Many Requests)" /tmp/test-output.log; then
                echo ""
                echo "‚ö†Ô∏è  Nx Cloud error detected - disabling Nx Cloud and retrying..."
                echo "   Error details:"
                grep -iE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection|authentication|unauthorized|NX_CLOUD)" /tmp/test-output.log | head -5 || true
                echo ""
                echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
                export NX_SKIP_NX_CLOUD=true
                
                # Retry without Nx Cloud - this should succeed
                echo "üß™ Retrying test without Nx Cloud (using local cache only)..."
                set +e  # Don't exit on error for retry
                eval "$TEST_CMD"
                RETRY_EXIT=$?  # Capture exit code (no pipe in retry)
                set -e
                
                if [ "$RETRY_EXIT" -ne 0 ]; then
                  echo "‚ùå Test failed even without Nx Cloud - this is a real error"
                  exit $RETRY_EXIT
                else
                  echo "‚úÖ Test succeeded without Nx Cloud"
                fi
              else
                # Not an Nx Cloud error - this is a real test error
                echo "‚ùå Test failed with non-Nx Cloud error - exiting"
                exit $TEST_EXIT
              fi
            else
              echo "‚úÖ Test succeeded with Nx Cloud"
            fi
          }

          run_test
          
          # Cleanup temporary log files
          rm -f /tmp/test-output.log 2>/dev/null || true

      - name: üèóÔ∏è Build all packages
        run: |
          # Function to run build with error handling for Nx Cloud failures
          run_build() {
            BUILD_CMD="pnpm nx run-many -t build --all --parallel=4 --verbose"
            
            # First attempt with Nx Cloud (if enabled)
            set +e  # Don't exit on error - we'll handle it
            eval "$BUILD_CMD" 2>&1 | tee /tmp/build-output.log
            BUILD_EXIT=${PIPESTATUS[0]}
            set -e  # Re-enable exit on error
            
            # If command failed, check if it's Nx Cloud related
            if [ "$BUILD_EXIT" -ne 0 ]; then
              # Check for any Nx Cloud related errors (quota, connection, auth, etc.)
              if grep -qiE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection.*failed|authentication.*failed|unauthorized|NX_CLOUD.*quota|rate.*limit.*exceeded|429.*Too Many Requests)" /tmp/build-output.log; then
                echo ""
                echo "‚ö†Ô∏è  Nx Cloud error detected - disabling Nx Cloud and retrying..."
                echo "   Error details:"
                grep -iE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection|authentication|unauthorized|NX_CLOUD)" /tmp/build-output.log | head -5 || true
                echo ""
                echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
                export NX_SKIP_NX_CLOUD=true
                
                # Retry without Nx Cloud - this should succeed
                echo "üèóÔ∏è Retrying build without Nx Cloud (using local cache only)..."
                set +e  # Don't exit on error for retry
                eval "$BUILD_CMD"
                RETRY_EXIT=$?  # Capture exit code (no pipe in retry)
                set -e
                
                if [ "$RETRY_EXIT" -ne 0 ]; then
                  echo "‚ùå Build failed even without Nx Cloud - this is a real error"
                  exit $RETRY_EXIT
                else
                  echo "‚úÖ Build succeeded without Nx Cloud"
                fi
              else
                # Not an Nx Cloud error - this is a real build error
                echo "‚ùå Build failed with non-Nx Cloud error - exiting"
                exit $BUILD_EXIT
              fi
            else
              echo "‚úÖ Build succeeded with Nx Cloud"
            fi
          }

          run_build
          
          # Cleanup temporary log files
          rm -f /tmp/build-output.log 2>/dev/null || true

      - name: ‚úÖ CI validation passed
        run: |
          echo "## ‚úÖ CI Validation Passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All tests and builds completed successfully." >> $GITHUB_STEP_SUMMARY

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # STEP 2: RELEASE (Version bump, build, changelog, tags, publish)
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  release:
    name: üöÄ Release & Publish
    runs-on: ubuntu-latest
    environment: production
    # Only require CI if it was enabled and run
    if: always() && (inputs.run-ci == false || needs.validate-ci.result == 'success' || needs.validate-ci.result == 'skipped')
    needs: [validate-ci]
    timeout-minutes: 15
    permissions:
      contents: write # Required to push commits/tags and create PRs
      id-token: write # ‚Üê Required for Trusted Publishing (OIDC)
      pull-requests: write # Required to create PR if direct push fails

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: main # Always checkout main branch for releases (ensures all tags are reachable)
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ‚öôÔ∏è Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: ‚öôÔ∏è Setup Node.js (Trusted Publishing for Scoped Packages)
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: https://registry.npmjs.org/
          cache: "pnpm"
          scope: "@forge-js"
          # Trusted Publishing (OIDC) is automatically configured for @forge-js scope
          # via NODE_AUTH_TOKEN environment variable
          # This ensures scoped packages use Trusted Publishing, not NPM_TOKEN

      - name: üìÇ Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: üîÑ Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: üì¶ Install dependencies
        run: pnpm install --frozen-lockfile

      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      # CONFIGURE NX CLOUD (Optional - skip if unavailable)
      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: üîó Configure Nx Cloud (Optional)
        continue-on-error: true
        run: |
          if [ -n "${{ secrets.NX_CLOUD_ACCESS_TOKEN }}" ]; then
            echo "üîó Connecting to Nx Cloud..."
            if npx nx connect-to-nx-cloud --quiet --no-interactive; then
              echo "‚úÖ Nx Cloud connected successfully"
            else
              echo "‚ö†Ô∏è  Nx Cloud connection failed, using local cache only"
              echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
            fi
          else
            echo "‚ÑπÔ∏è  NX_CLOUD_ACCESS_TOKEN not set, using local cache only"
            echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
          fi
        env:
          NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN }}

      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      # VERIFY TRUSTED PUBLISHING (SCOPED PACKAGES ONLY)
      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: üîç Verify Trusted Publishing
        if: inputs.dry-run == false
        run: |
          echo "üîç Verifying Trusted Publishing for scoped packages..."
          echo ""
          echo "üì¶ This workflow publishes SCOPED packages only:"
          echo "   - @forge-js/eslint-plugin-llm-optimized"
          echo "   - @forge-js/eslint-plugin-utils"
          echo "   - @forge-js/cli"
          echo ""
          echo "üì¶ For UNscoped packages, use: release-unscoped.yml workflow"
          echo ""

          if [ -z "$NODE_AUTH_TOKEN" ]; then
            echo "‚ùå NODE_AUTH_TOKEN not found - Trusted Publishing not configured"
            echo "   Check: https://www.npmjs.com/org/forge-js/settings/publishing"
            exit 1
          fi

          echo "‚úÖ Trusted Publishing configured (NODE_AUTH_TOKEN found)"
          echo "   Scope: @forge-js (set in setup-node@v6)"
          echo "   Authentication: OIDC via Trusted Publishing"

      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      # QUICK PRE-FLIGHT CHECK (SCOPED PACKAGES ONLY)
      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: üîç Quick Pre-Flight Check
        if: inputs.dry-run == false
        run: |
          # Verify Trusted Publishing (OIDC) for scoped packages
          echo "üîç Checking Trusted Publishing authentication..."

          if [ -n "$NODE_AUTH_TOKEN" ]; then
            echo "‚úÖ NODE_AUTH_TOKEN found (Trusted Publishing available)"
            echo "   Scope: @forge-js (configured in setup-node@v6)"
          else
            echo "‚ùå NODE_AUTH_TOKEN not found - Trusted Publishing not configured"
            echo "   Check: https://www.npmjs.com/org/forge-js/settings/publishing"
            exit 1
          fi

          echo "‚úÖ Authentication ready for scoped packages"

      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      # PHASE 1: PREPARE VERSION (Build + determine versions + update changelogs)
      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: üìù Prepare Release Version
        id: prepare
        if: inputs.dry-run == false
        run: |
          # Configure git user for automated commits
          git config user.name "Ofri Peretz"
          git config user.email "ofriperetzdev@gmail.com"

          # Explicit list of scoped packages
          # Projects: eslint-plugin ‚Üí @forge-js/eslint-plugin-llm-optimized
          #           eslint-plugin-utils ‚Üí @forge-js/eslint-plugin-utils
          #           cli ‚Üí @forge-js/cli
          SCOPED_PROJECTS="eslint-plugin,eslint-plugin-utils,cli"

          # Get affected projects and filter to only scoped packages
          echo "üîç Detecting affected scoped packages..."
          AFFECTED_PROJECTS=$(pnpm nx show projects --affected --base=HEAD~1 2>/dev/null | grep -E "^($(echo $SCOPED_PROJECTS | tr ',' '|'))$" | tr '\n' ',' | sed 's/,$//' || echo "")

          if [ -z "$AFFECTED_PROJECTS" ]; then
            echo "‚ÑπÔ∏è  No affected scoped packages detected"
            echo "   Checking all scoped packages for changes..."
            # Fallback: check if any scoped project has changes
            for PROJECT in $(echo $SCOPED_PROJECTS | tr ',' ' '); do
              if git diff --quiet HEAD~1 HEAD -- "packages/$PROJECT" 2>/dev/null; then
                echo "   - $PROJECT: no changes"
              else
                echo "   - $PROJECT: has changes"
                if [ -z "$AFFECTED_PROJECTS" ]; then
                  AFFECTED_PROJECTS="$PROJECT"
                else
                  AFFECTED_PROJECTS="$AFFECTED_PROJECTS,$PROJECT"
                fi
              fi
            done
          fi

          if [ -z "$AFFECTED_PROJECTS" ]; then
            echo "‚úÖ No scoped packages have changes - nothing to release"
            echo "status=skipped" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "üì¶ Affected SCOPED packages: $AFFECTED_PROJECTS"
          echo "   (filtered from explicit list: $SCOPED_PROJECTS)"
          echo ""

          # Function to run version command with affected projects only
          run_version_command() {
            if [ "${{ inputs.version-specifier }}" != "auto" ]; then
              echo "üìù Using version strategy: ${{ inputs.version-specifier }}"
              VERSION_CMD="pnpm nx release version ${{ inputs.version-specifier }} --projects=$AFFECTED_PROJECTS"
            else
              echo "üìù Using conventional commits to determine version"
              VERSION_CMD="pnpm nx release version --projects=$AFFECTED_PROJECTS"
            fi
            
            # First attempt with Nx Cloud (if enabled)
            set +e  # Don't exit on error - we'll handle it
            eval "$VERSION_CMD" 2>&1 | tee /tmp/nx-release-output.log
            VERSION_EXIT=${PIPESTATUS[0]}
            set -e  # Re-enable exit on error
            
            # If command failed, check if it's Nx Cloud related
            if [ "$VERSION_EXIT" -ne 0 ]; then
              # Check for any Nx Cloud related errors (quota, connection, auth, etc.)
              if grep -qiE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection.*failed|authentication.*failed|unauthorized|NX_CLOUD.*quota|rate.*limit.*exceeded|429.*Too Many Requests)" /tmp/nx-release-output.log; then
                echo ""
                echo "‚ö†Ô∏è  Nx Cloud error detected - disabling Nx Cloud and retrying..."
                echo "   Error details:"
                grep -iE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection|authentication|unauthorized|NX_CLOUD)" /tmp/nx-release-output.log | head -5 || true
                echo ""
                echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
                export NX_SKIP_NX_CLOUD=true
                
                # Retry without Nx Cloud - this should succeed
                echo "üìù Retrying version command without Nx Cloud (using local cache only)..."
                set +e  # Don't exit on error for retry
                eval "$VERSION_CMD" 2>&1 | tee /tmp/nx-release-output.log
                RETRY_EXIT=${PIPESTATUS[0]}
                set -e
                
                if [ "$RETRY_EXIT" -ne 0 ]; then
                  # Not an Nx Cloud error - return exit code for further handling (tag conflicts, etc.)
                  return $RETRY_EXIT
                else
                  echo "‚úÖ Version command succeeded without Nx Cloud"
                  return 0
                fi
              else
                # Not an Nx Cloud error - return exit code for further handling (tag conflicts, etc.)
                return $VERSION_EXIT
              fi
            else
              echo "‚úÖ Version command succeeded with Nx Cloud"
              return 0
            fi
          }

          # Try to run version command
          run_version_command
          EXIT_CODE=$?
          if [ "$EXIT_CODE" -ne 0 ]; then
            echo ""
            echo "‚ö†Ô∏è  Version command failed with exit code: $EXIT_CODE"
            
            # Check if the error is about existing tags
            if grep -q "tag.*already exists" /tmp/nx-release-output.log; then
              echo "üßπ Detected existing tags from previous failed release attempt"
              echo "   Checking if corresponding npm versions exist..."
              
              # Extract tag names from error message
              CONFLICTING_TAGS=$(grep -oE '[a-z-]+@[0-9]+\.[0-9]+\.[0-9]+' /tmp/nx-release-output.log | sort -u || echo "")
              
              if [ -n "$CONFLICTING_TAGS" ]; then
                for TAG in $CONFLICTING_TAGS; do
                  # Extract project name and version from tag (format: project@version)
                  PROJECT=$(echo "$TAG" | cut -d'@' -f1)
                  VERSION=$(echo "$TAG" | cut -d'@' -f2)
                  
                  echo "   üîç Checking tag: $TAG"
                  
                  # Get package name from project.json or package.json
                  PACKAGE_NAME=""
                  if [ -f "packages/${PROJECT}/package.json" ]; then
                    PACKAGE_NAME=$(node -p "require('./packages/${PROJECT}/package.json').name" 2>/dev/null || echo "")
                  fi
                  
                  if [ -z "$PACKAGE_NAME" ]; then
                    # Try to map project name to package name
                    case "$PROJECT" in
                      "eslint-plugin")
                        PACKAGE_NAME="@forge-js/eslint-plugin-llm-optimized"
                        ;;
                      "eslint-plugin-utils")
                        PACKAGE_NAME="@forge-js/eslint-plugin-utils"
                        ;;
                      "cli")
                        PACKAGE_NAME="@forge-js/cli"
                        ;;
                      *)
                        PACKAGE_NAME="$PROJECT"
                        ;;
                    esac
                  fi
                  
                  # Check if version exists on npm
                  echo "      Checking npm for: $PACKAGE_NAME@$VERSION"
                  if npm view "${PACKAGE_NAME}@${VERSION}" version >/dev/null 2>&1; then
                    echo "      ‚úÖ Version $VERSION exists on npm - skipping tag deletion"
                    echo "      ‚ÑπÔ∏è  Package already published, will skip in publish step"
                  else
                    echo "      ‚ùå Version $VERSION does NOT exist on npm"
                    echo "      üóëÔ∏è  Deleting tag $TAG (tag exists but npm version doesn't)"
                    git tag -d "$TAG" 2>/dev/null || true
                    git push origin ":refs/tags/$TAG" 2>/dev/null || true
                    echo "      ‚úÖ Tag deleted - will be recreated by nx release version"
                  fi
                done
                
                echo "   ‚úÖ Cleaned up tags where npm versions don't exist"
                echo "   üîÑ Retrying version command (will recreate deleted tags)..."
                run_version_command
                
                # Verify tags were recreated
                echo "   üîç Verifying tags were recreated..."
                for TAG in $CONFLICTING_TAGS; do
                  PROJECT=$(echo "$TAG" | cut -d'@' -f1)
                  VERSION=$(echo "$TAG" | cut -d'@' -f2)
                  
                  if [ -f "packages/${PROJECT}/package.json" ]; then
                    PACKAGE_NAME=$(node -p "require('./packages/${PROJECT}/package.json').name" 2>/dev/null || echo "")
                    if [ -z "$PACKAGE_NAME" ]; then
                      case "$PROJECT" in
                        "eslint-plugin")
                          PACKAGE_NAME="@forge-js/eslint-plugin-llm-optimized"
                          ;;
                        "eslint-plugin-utils")
                          PACKAGE_NAME="@forge-js/eslint-plugin-utils"
                          ;;
                        "cli")
                          PACKAGE_NAME="@forge-js/cli"
                          ;;
                        *)
                          PACKAGE_NAME="$PROJECT"
                          ;;
                      esac
                    fi
                    
                    # Only check if npm version doesn't exist (we deleted the tag for these)
                    if ! npm view "${PACKAGE_NAME}@${VERSION}" version >/dev/null 2>&1; then
                      if git rev-parse "$TAG" >/dev/null 2>&1; then
                        echo "      ‚úÖ Tag $TAG was successfully recreated"
                      else
                        echo "      ‚ö†Ô∏è  Warning: Tag $TAG was not recreated, creating manually..."
                        # Get the current commit (where package.json was updated)
                        COMMIT_SHA=$(git rev-parse HEAD)
                        git tag "$TAG" "$COMMIT_SHA"
                        echo "      ‚úÖ Manually created tag $TAG"
                      fi
                    fi
                  fi
                done
              else
                # Fallback: try to extract from updated package.json files
                echo "   üîç Attempting to extract from package.json files..."
                UPDATED_FILES=$(git diff --name-only HEAD packages/*/package.json dist/packages/*/package.json 2>/dev/null || echo "")
                
                if [ -n "$UPDATED_FILES" ]; then
                  for FILE in $UPDATED_FILES; do
                    if [ -f "$FILE" ]; then
                      PACKAGE_NAME=$(node -p "require('./$FILE').name" 2>/dev/null || echo "")
                      NEW_VERSION=$(node -p "require('./$FILE').version" 2>/dev/null || echo "")
                      
                      if [ -n "$PACKAGE_NAME" ] && [ -n "$NEW_VERSION" ]; then
                        # Map to project name
                        PROJECT=$(echo "$FILE" | sed -n 's|.*packages/\([^/]*\)/.*|\1|p')
                        if [ -n "$PROJECT" ]; then
                          TAG="${PROJECT}@${NEW_VERSION}"
                          if git rev-parse "$TAG" >/dev/null 2>&1; then
                            # Check npm
                            if ! npm view "${PACKAGE_NAME}@${NEW_VERSION}" version >/dev/null 2>&1; then
                              echo "   üóëÔ∏è  Deleting tag $TAG (npm version doesn't exist)"
                              git tag -d "$TAG" 2>/dev/null || true
                              git push origin ":refs/tags/$TAG" 2>/dev/null || true
                              echo "   ‚úÖ Tag deleted - will be recreated by nx release version"
                            fi
                          fi
                        fi
                      fi
                    fi
                  done
                  
                  echo "   ‚úÖ Cleaned up tags where npm versions don't exist"
                  echo "   üîÑ Retrying version command (will recreate deleted tags)..."
                  run_version_command
                  
                  # Verify tags were recreated for packages that need publishing
                  echo "   üîç Verifying tags were recreated for unpublished packages..."
                  for FILE in $UPDATED_FILES; do
                    if [ -f "$FILE" ]; then
                      PACKAGE_NAME=$(node -p "require('./$FILE').name" 2>/dev/null || echo "")
                      NEW_VERSION=$(node -p "require('./$FILE').version" 2>/dev/null || echo "")
                      PROJECT=$(echo "$FILE" | sed -n 's|.*packages/\([^/]*\)/.*|\1|p')
                      
                      if [ -n "$PACKAGE_NAME" ] && [ -n "$NEW_VERSION" ] && [ -n "$PROJECT" ]; then
                        TAG="${PROJECT}@${NEW_VERSION}"
                        # Only verify if npm version doesn't exist (we want to publish this)
                        if ! npm view "${PACKAGE_NAME}@${NEW_VERSION}" version >/dev/null 2>&1; then
                          if git rev-parse "$TAG" >/dev/null 2>&1; then
                            echo "      ‚úÖ Tag $TAG was successfully recreated"
                          else
                            echo "      ‚ö†Ô∏è  Warning: Tag $TAG was not recreated, creating manually..."
                            COMMIT_SHA=$(git rev-parse HEAD)
                            git tag "$TAG" "$COMMIT_SHA"
                            echo "      ‚úÖ Manually created tag $TAG"
                          fi
                        fi
                      fi
                    fi
                  done
                else
                  echo "   ‚ùå Could not determine which tags to check"
                  exit $EXIT_CODE
                fi
              fi
            else
              echo "   ‚ùå Version command failed for a different reason"
              cat /tmp/nx-release-output.log
              exit $EXIT_CODE
            fi
          fi

          echo "status=success" >> $GITHUB_OUTPUT
          
          # Cleanup temporary log files
          rm -f /tmp/nx-release-output.log 2>/dev/null || true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      # PHASE 2: CREATE RELEASE PR
      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      # After nx release version creates commits and tags, create a PR with all changes
      - name: üìù Create Release PR
        if: inputs.dry-run == false
        run: |
          echo "üìù Creating release PR with version changes..."

          # Fetch latest from origin
          git fetch origin main

          # Check for new commits and tags created by nx release version
          COMMITS=$(git log origin/main..HEAD --oneline | wc -l | tr -d ' ')
          TAGS=$(git tag --list --no-merged origin/main | wc -l | tr -d ' ')

          if [ "$COMMITS" -eq 0 ] && [ "$TAGS" -eq 0 ]; then
            echo "‚ÑπÔ∏è  No new changes - versions already on main, skipping PR creation"
          else
            echo "üìù Found $COMMITS commit(s) and $TAGS tag(s) to release"
            
            # Create release branch from current state (after nx release version)
            RELEASE_BRANCH="chore/release-$(date +%Y%m%d-%H%M%S)"
            git checkout -b "$RELEASE_BRANCH"
            
            # Push branch with commits and tags
            echo "üì§ Pushing release branch with commits and tags..."
            git push origin "$RELEASE_BRANCH" || exit 1
            
            # Push tags (ignore errors if tags already exist - they may have been pushed in a previous attempt)
            echo "üì§ Pushing tags..."
            if git push origin --tags 2>&1 | tee /tmp/tag-push.log; then
              echo "‚úÖ Tags pushed successfully"
            else
              TAG_PUSH_EXIT=${PIPESTATUS[0]}
              if grep -q "already exists\|Everything up-to-date" /tmp/tag-push.log; then
                echo "‚ö†Ô∏è  Some tags already exist on remote (from previous attempt)"
                echo "   This is safe - tags are already pushed, continuing..."
              else
                echo "‚ùå Tag push failed with unexpected error:"
                cat /tmp/tag-push.log
                exit $TAG_PUSH_EXIT
              fi
            fi
            
            # Create PR using GitHub CLI (always available in GitHub Actions)
            PR_TITLE="chore(release): Update package versions"
            PR_BODY=$(printf "ü§ñ **Automated Release PR**\n\nThis PR contains:\n- Package version updates\n- CHANGELOG updates\n- Git tags: %s\n\n**Note:** Packages are being published to npm in parallel with this PR." "$TAGS")
            
            # Try to create PR (capture both output and exit code)
            set +e  # Temporarily disable exit on error
            PR_OUTPUT=$(gh pr create \
              --title "$PR_TITLE" \
              --body "$PR_BODY" \
              --base main \
              --head "$RELEASE_BRANCH" \
              --json url --jq '.url' 2>&1)
            PR_EXIT_CODE=$?
            set -e  # Re-enable exit on error
            
            if [ $PR_EXIT_CODE -eq 0 ] && [ -n "$PR_OUTPUT" ]; then
              echo "‚úÖ Created release PR: $PR_OUTPUT"
              echo "pr_url=$PR_OUTPUT" >> $GITHUB_ENV
            else
              echo "‚ö†Ô∏è  Failed to create PR via CLI (exit code: $PR_EXIT_CODE)"
              echo "   Branch is pushed and ready for manual PR creation:"
              echo "   https://github.com/${{ github.repository }}/compare/main...$RELEASE_BRANCH?expand=1"
              if [ -n "$PR_OUTPUT" ]; then
                echo "   Error output: $PR_OUTPUT"
              fi
              # Don't fail the workflow - publishing can still proceed
              echo "‚ÑπÔ∏è  Continuing workflow - publishing will proceed"
            fi
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      # PHASE 3: PUBLISH PACKAGES
      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      # Publish SCOPED packages that were affected by the latest commits (based on tags)
      - name: üöÄ Publish Scoped Packages
        id: publish
        if: inputs.dry-run == false
        run: |
          echo "üöÄ Publishing SCOPED packages with dist tag: ${{ inputs.dist-tag }}"
          echo ""
          echo "üì¶ This workflow publishes SCOPED packages only (@forge-js/*):"
          echo "   - @forge-js/eslint-plugin-llm-optimized"
          echo "   - @forge-js/eslint-plugin-utils"
          echo "   - @forge-js/cli"
          echo ""
          echo "üì¶ For UNscoped packages, use: release-unscoped.yml workflow"
          echo ""
          echo "üì¶ Nx will automatically publish only packages affected by recent commits"
          echo "   (determined by git tags created in the version step)"
          echo ""

          # Configure git user
          git config user.name "Ofri Peretz"
          git config user.email "ofriperetzdev@gmail.com"

          # Verify Trusted Publishing is available
          if [ -z "$NODE_AUTH_TOKEN" ]; then
            echo "‚ùå NODE_AUTH_TOKEN not found - Trusted Publishing not configured"
            echo "   Check: https://www.npmjs.com/org/forge-js/settings/publishing"
            exit 1
          fi

          echo "‚úÖ Trusted Publishing verified (NODE_AUTH_TOKEN found)"
          echo "   Scope: @forge-js (configured in setup-node@v6)"
          echo "   Authentication: OIDC via Trusted Publishing"

          # Verify .npmrc configuration
          if [ -f ".npmrc" ]; then
            echo "‚úÖ .npmrc found"
            echo "   All packages in this workflow use Trusted Publishing (OIDC)"
            echo ""
            echo "   Packages being published:"
            echo "   - @forge-js/eslint-plugin-llm-optimized ‚Üí Trusted Publishing"
            echo "   - @forge-js/eslint-plugin-utils ‚Üí Trusted Publishing"
            echo "   - @forge-js/cli ‚Üí Trusted Publishing"
          fi

          # Publish packages
          # Nx automatically handles dependency order via "^nx-release-publish" in project.json
          # Publish order: eslint-plugin-utils ‚Üí eslint-plugin ‚Üí dependents
          echo ""
          echo "üì§ Publishing packages with nx release publish..."
          echo "   Nx will publish in dependency order based on project.json 'dependsOn' configuration"
          echo ""

          # Explicit list of scoped packages
          SCOPED_PROJECTS="eslint-plugin,eslint-plugin-utils,cli"

          # Get affected projects and filter to only scoped packages
          echo "üîç Detecting affected scoped packages for publishing..."
          AFFECTED_PROJECTS=$(pnpm nx show projects --affected --base=HEAD~1 2>/dev/null | grep -E "^($(echo $SCOPED_PROJECTS | tr ',' '|'))$" | tr '\n' ',' | sed 's/,$//' || echo "")

          if [ -z "$AFFECTED_PROJECTS" ]; then
            echo "‚ÑπÔ∏è  No affected scoped packages detected"
            echo "   Checking for packages with new tags (from version step)..."
            # Check for packages that have new tags (created in version step)
            for PROJECT in $(echo $SCOPED_PROJECTS | tr ',' ' '); do
              # Check if there's a new tag for this project
              LATEST_TAG=$(git tag --sort=-version:refname | grep "^${PROJECT}@" | head -n 1)
              if [ -n "$LATEST_TAG" ]; then
                # Check if tag is new (not in remote or different from previous)
                if [ -z "$AFFECTED_PROJECTS" ]; then
                  AFFECTED_PROJECTS="$PROJECT"
                else
                  AFFECTED_PROJECTS="$AFFECTED_PROJECTS,$PROJECT"
                fi
                echo "   - $PROJECT: has new tag $LATEST_TAG"
              fi
            done
          fi

          if [ -z "$AFFECTED_PROJECTS" ]; then
            echo "‚úÖ No scoped packages to publish - nothing was versioned"
            exit 0
          fi

          echo "üì¶ Publishing affected SCOPED packages: $AFFECTED_PROJECTS"
          echo "   (filtered from explicit list: $SCOPED_PROJECTS)"
          echo ""

          # Function to run publish command with Nx Cloud error handling
          run_publish_command() {
            PUBLISH_CMD="pnpm nx release publish --tag ${{ inputs.dist-tag }} --projects=$AFFECTED_PROJECTS"
            
            # First attempt with Nx Cloud (if enabled)
            set +e  # Don't exit on error - we'll handle it
            PUBLISH_OUTPUT=$(eval "$PUBLISH_CMD" 2>&1)
            PUBLISH_EXIT=$?
            set -e  # Re-enable exit on error
            
            # If command failed, check if it's Nx Cloud related
            if [ "$PUBLISH_EXIT" -ne 0 ]; then
              # Check for any Nx Cloud related errors (quota, connection, auth, etc.)
              if echo "$PUBLISH_OUTPUT" | grep -qiE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection.*failed|authentication.*failed|unauthorized|NX_CLOUD.*quota|rate.*limit.*exceeded|429.*Too Many Requests)"; then
                echo ""
                echo "‚ö†Ô∏è  Nx Cloud error detected - disabling Nx Cloud and retrying..."
                echo "   Error details:"
                echo "$PUBLISH_OUTPUT" | grep -iE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection|authentication|unauthorized|NX_CLOUD)" | head -5 || true
                echo ""
                echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
                export NX_SKIP_NX_CLOUD=true
                
                # Retry without Nx Cloud - this should succeed
                echo "üöÄ Retrying publish command without Nx Cloud (using local cache only)..."
                set +e  # Don't exit on error for retry
                PUBLISH_OUTPUT=$(eval "$PUBLISH_CMD" 2>&1)
                PUBLISH_EXIT=$?
                set -e
                
                if [ "$PUBLISH_EXIT" -ne 0 ]; then
                  # Not an Nx Cloud error - return for further handling (already published, etc.)
                  return $PUBLISH_EXIT
                else
                  echo "‚úÖ Publish command succeeded without Nx Cloud"
                  return 0
                fi
              else
                # Not an Nx Cloud error - return for further handling (already published, etc.)
                return $PUBLISH_EXIT
              fi
            else
              echo "‚úÖ Publish command succeeded with Nx Cloud"
              return 0
            fi
          }

          # Run publish command and capture output
          run_publish_command || PUBLISH_EXIT=$?
          if [ -z "$PUBLISH_EXIT" ] || [ "$PUBLISH_EXIT" -eq 0 ]; then
            echo "‚úÖ All packages published successfully"
          else
            echo ""
            echo "‚ö†Ô∏è  Publishing encountered issues (exit code: ${PUBLISH_EXIT:-1})"
            echo ""
            
            # Check for "already published" errors (403/409) - these are safe to ignore
            ALREADY_PUBLISHED_COUNT=$(echo "$PUBLISH_OUTPUT" | grep -c "already published\|cannot publish over\|E403\|E409" || true)
            ALREADY_PUBLISHED_COUNT=${ALREADY_PUBLISHED_COUNT:-0}
            UNEXPECTED_ERRORS=$(echo "$PUBLISH_OUTPUT" | grep -v "already published\|cannot publish over\|E403\|E409" | grep -i "error\|failed" || echo "")
            
            if [ "$ALREADY_PUBLISHED_COUNT" -gt 0 ]; then
              echo "‚ÑπÔ∏è  Found $ALREADY_PUBLISHED_COUNT package(s) already published on npm"
              echo "   This is safe - packages were published in a previous attempt"
              echo "   Continuing workflow..."
              echo ""
            fi
            
            # Check if there are unexpected errors (not "already published")
            if [ -n "$UNEXPECTED_ERRORS" ]; then
              echo "‚ùå Unexpected publishing errors detected:"
              echo ""
              echo "$PUBLISH_OUTPUT" | grep -i "error\|failed" | grep -v "already published\|cannot publish over\|E403\|E409" || echo "$PUBLISH_OUTPUT"
              echo ""
              
              # Check specifically for 404 errors
              if echo "$PUBLISH_OUTPUT" | grep -q "E404\|404 Not Found"; then
                echo "üîç 404 Error Analysis:"
                echo ""
                echo "404 errors mean the package doesn't exist in npm registry."
                echo ""
                echo "For Scoped Packages (@forge-js/*) with 404:"
                echo "  ‚ùå This indicates Trusted Publishing is NOT working"
                echo "  ‚Üí The package should be created automatically on first publish"
                echo "  ‚Üí 404 means npm can't find/create the package"
                echo "  ‚Üí Check: https://www.npmjs.com/org/forge-js/settings/publishing"
                echo "  ‚Üí Verify GitHub Actions is listed as a Trusted Publisher"
                echo "  ‚Üí Ensure the workflow has 'id-token: write' permission"
                echo ""
                echo "For Unscoped Packages (eslint-plugin-*) with 404:"
                echo "  ‚Üí Trusted Publishing doesn't work for unscoped packages by default"
                echo "  ‚Üí NPM_TOKEN (Granular Access Token) should be configured"
                echo "  ‚Üí Verify NPM_TOKEN secret is set in GitHub repository secrets"
                echo "  ‚Üí Check token has 'Publish packages' permission"
                echo "  ‚Üí Options:"
                echo "    1. Verify NPM_TOKEN secret is correctly set"
                echo "    2. Check token permissions include 'Publish packages'"
                echo "    3. Move packages to @forge-js scope (recommended long-term)"
                echo ""
              else
                echo "üîç Troubleshooting by package type:"
                echo ""
                echo "For Scoped Packages (@forge-js/*):"
                echo "  ‚Üí Trusted Publishing should work automatically"
                echo "  ‚Üí Verify: https://www.npmjs.com/org/forge-js/settings/publishing"
                echo "  ‚Üí Packages: @forge-js/eslint-plugin-llm-optimized, @forge-js/eslint-plugin-utils, @forge-js/cli"
                echo ""
                echo "For Unscoped Packages (eslint-plugin-*):"
                echo "  ‚Üí Trusted Publishing doesn't work for unscoped packages"
                echo "  ‚Üí Using NPM_TOKEN (Granular Access Token) - verify it's configured"
                echo "  ‚Üí Packages: eslint-plugin-llm-optimized, eslint-plugin-llm, eslint-plugin-mcp, eslint-plugin-mcp-optimized"
                echo "  ‚Üí Check: NPM_TOKEN secret exists and has 'Publish packages' permission"
                echo ""
              fi
              
              exit ${PUBLISH_EXIT:-1}
            else
              # Only "already published" errors - safe to continue
              echo "‚úÖ All errors were 'already published' - workflow can continue"
              echo "   Remaining packages (if any) will be published on next run"
            fi
          fi
          
          # Cleanup temporary log files
          rm -f /tmp/publish-output.log 2>/dev/null || true
        env:
          NPM_CONFIG_PROVENANCE: true
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # NODE_AUTH_TOKEN is automatically set by setup-node@v6 for Trusted Publishing (scoped packages)
          # NPM_TOKEN is NOT needed - this workflow only handles scoped packages
          # Skip Nx Cloud if connection failed or token not set (falls back to local cache)
          NX_SKIP_NX_CLOUD: ${{ env.NX_SKIP_NX_CLOUD || 'false' }}

      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      # DRY RUN: Just preview changes
      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: üîç Dry Run Preview
        if: inputs.dry-run == true
        run: |
          echo "üîç DRY RUN MODE: Previewing changes only"

          # Construct the dry-run flag
          DRY_RUN_FLAG="--dry-run"

          # Explicit list of scoped packages
          SCOPED_PROJECTS="eslint-plugin,eslint-plugin-utils,cli"

          # Get affected projects and filter to only scoped packages
          echo "üîç Detecting affected scoped packages for dry-run..."
          AFFECTED_PROJECTS=$(pnpm nx show projects --affected --base=HEAD~1 2>/dev/null | grep -E "^($(echo $SCOPED_PROJECTS | tr ',' '|'))$" | tr '\n' ',' | sed 's/,$//' || echo "")

          if [ -z "$AFFECTED_PROJECTS" ]; then
            echo "‚ÑπÔ∏è  No affected scoped packages detected - will preview all scoped packages"
            AFFECTED_PROJECTS="$SCOPED_PROJECTS"
          fi

          echo "üì¶ DRY RUN: Previewing affected SCOPED packages: $AFFECTED_PROJECTS"
          echo "   (filtered from explicit list: $SCOPED_PROJECTS)"
          echo ""

          # Function to run dry-run version command with Nx Cloud error handling
          run_dry_run_version() {
            if [ "${{ inputs.version-specifier }}" != "auto" ]; then
              echo "üìù Previewing version strategy: ${{ inputs.version-specifier }}"
              VERSION_CMD="pnpm nx release version ${{ inputs.version-specifier }} --projects=$AFFECTED_PROJECTS $DRY_RUN_FLAG"
            else
              echo "üìù Previewing conventional commits version"
              VERSION_CMD="pnpm nx release version --projects=$AFFECTED_PROJECTS $DRY_RUN_FLAG"
            fi
            
            # First attempt with Nx Cloud (if enabled)
            set +e  # Don't exit on error - we'll handle it
            eval "$VERSION_CMD" 2>&1 | tee /tmp/dry-run-output.log
            VERSION_EXIT=${PIPESTATUS[0]}
            set -e  # Re-enable exit on error
            
            # If command failed, check if it's Nx Cloud related
            if [ "$VERSION_EXIT" -ne 0 ]; then
              # Check for any Nx Cloud related errors (quota, connection, auth, etc.)
              if grep -qiE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection.*failed|authentication.*failed|unauthorized|NX_CLOUD.*quota|rate.*limit.*exceeded|429.*Too Many Requests)" /tmp/dry-run-output.log; then
                echo ""
                echo "‚ö†Ô∏è  Nx Cloud error detected - disabling Nx Cloud and retrying..."
                echo "   Error details:"
                grep -iE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection|authentication|unauthorized|NX_CLOUD)" /tmp/dry-run-output.log | head -5 || true
                echo ""
                echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
                export NX_SKIP_NX_CLOUD=true
                
                # Retry without Nx Cloud - this should succeed
                echo "üìù Retrying dry-run version command without Nx Cloud (using local cache only)..."
                set +e  # Don't exit on error for retry
                eval "$VERSION_CMD"
                RETRY_EXIT=$?  # Capture exit code (no pipe in retry)
                set -e
                
                if [ "$RETRY_EXIT" -ne 0 ]; then
                  echo "‚ùå Dry-run failed even without Nx Cloud - this is a real error"
                  exit $RETRY_EXIT
                else
                  echo "‚úÖ Dry-run succeeded without Nx Cloud"
                fi
              else
                # Not an Nx Cloud error - this is a real error
                echo "‚ùå Dry-run failed with non-Nx Cloud error - exiting"
                exit $VERSION_EXIT
              fi
            else
              echo "‚úÖ Dry-run succeeded with Nx Cloud"
            fi
          }
          
          run_dry_run_version
          
          # Cleanup temporary log files
          rm -f /tmp/dry-run-output.log 2>/dev/null || true

      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      # SUMMARY REPORTING
      # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: üìä Generate Release Summary
        run: |
          if [ "${{ inputs.dry-run }}" = "true" ]; then
            echo "## üîç Dry Run Preview Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Version Strategy:** ${{ inputs.version-specifier }}" >> $GITHUB_STEP_SUMMARY
            echo "**Dist Tag:** ${{ inputs.dist-tag }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ This was a dry-run preview - no changes committed" >> $GITHUB_STEP_SUMMARY
          else
            echo "## üéâ Release Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Version Strategy:** ${{ inputs.version-specifier }}" >> $GITHUB_STEP_SUMMARY
            echo "**Dist Tag:** \`${{ inputs.dist-tag }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Published Packages" >> $GITHUB_STEP_SUMMARY
            echo "- \`@forge-js/eslint-plugin\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`@forge-js/eslint-plugin-llm-optimized\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`@forge-js/eslint-plugin-utils\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`@forge-js/cli\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`@forge-js/eslint-plugin-llm\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`@forge-js/eslint-plugin-mcp\`" >> $GITHUB_STEP_SUMMARY
            echo "- \`@forge-js/eslint-plugin-mcp-optimized\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "To install the new version:" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "pnpm add @forge-js/eslint-plugin@${{ inputs.dist-tag }}" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
