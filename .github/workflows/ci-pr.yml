name: CI Workflow

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

# Prevent concurrent runs on the same branch to save quota
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Determine the environment based on the trigger
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ci:
    name: CI
    runs-on: ubuntu-latest
    environment: ${{ github.event_name == 'pull_request' && 'development' || 'staging' }}

    # Prevent hanging builds
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          fetch-tags: true

      # Note: Nx's git-tag resolver only sees tags reachable from current HEAD.
      # PR branches may not include commits where tags were created on main.
      # The fallbackCurrentVersionResolver: "disk" in nx.json will read from package.json
      # when git-tag fails, but it only triggers when NO tag is found, not when an old tag is found.
      # For PR validation, we accept that version resolution may be imperfect.

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # EARLY CHECK: DOCS-ONLY CHANGES (skip full CI if only docs/md changed)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Check if changes are docs-only
        id: docs_only
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # Get changed files for PR
            CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
          else
            # Get changed files for push to main
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"
          echo ""

          # Check if all changed files are docs or markdown
          DOCS_ONLY=true
          while IFS= read -r file; do
            # Skip empty lines
            [[ -z "$file" ]] && continue
            # Check if file matches docs or markdown patterns
            if ! [[ "$file" =~ ^docs/ || "$file" =~ \.md$ || "$file" =~ README || "$file" =~ CHANGELOG ]]; then
              DOCS_ONLY=false
              break
            fi
          done <<< "$CHANGED_FILES"

          if [[ "$DOCS_ONLY" == "true" && -n "$CHANGED_FILES" ]]; then
            echo "âœ… Only documentation and markdown files changed - skipping full CI"
            echo "docs_only=true" >> $GITHUB_OUTPUT
          else
            echo "âš™ï¸  Non-docs files changed - running full CI pipeline"
            echo "docs_only=false" >> $GITHUB_OUTPUT
          fi

      - name: âœ… Skip CI for docs-only changes
        if: steps.docs_only.outputs.docs_only == 'true'
        run: |
          echo "âœ… CI passed automatically - only documentation and markdown files were changed"
          exit 0

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # LAYER 1: PNPM PACKAGE MANAGER SETUP (BEFORE Node setup)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.18.3

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # LAYER 2: NODE RUNTIME & BUILT-IN CACHING (NOW pnpm is available)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 20
          cache: "pnpm"

      - name: Install dependencies (with cache)
        run: pnpm install --frozen-lockfile

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # LAYER 3: NX CLOUD CONNECTION (Optional - falls back to local cache if quota exceeded)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: ğŸ”— Configure Nx Cloud (Optional)
        continue-on-error: true
        run: |
          if [ -n "${{ secrets.NX_CLOUD_ACCESS_TOKEN }}" ]; then
            echo "ğŸ”— Connecting to Nx Cloud..."
            if npx nx connect-to-nx-cloud --quiet --no-interactive; then
              echo "âœ… Nx Cloud connected successfully"
            else
              echo "âš ï¸  Nx Cloud connection failed, using local cache only"
              echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
            fi
          else
            echo "â„¹ï¸  NX_CLOUD_ACCESS_TOKEN not set, using local cache only"
            echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
          fi
        env:
          NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN }}

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # LAYER 4: DERIVE AFFECTED PACKAGES (no artifact caching)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Derive affected packages using NX
        uses: nrwl/nx-set-shas@v4
        with:
          main-branch-name: main

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # LAYER 5: TEST & BUILD (with graceful Nx Cloud fallback)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # We run test first with coverage enabled, then build.
      # Build depends on test (Nx dependency), but we run both explicitly to ensure
      # tests always run even if build is cached (build dependency doesn't re-run if cached)
      # Note: If Nx Cloud quota is exceeded, Nx will automatically fall back to local cache

      - name: Test Affected Packages
        run: |
          # Function to run test with error handling for Nx Cloud failures
          run_test() {
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              echo "ğŸ“Š Testing affected packages..."
              TEST_CMD="pnpm nx affected -t test -c ci --parallel=4 --verbose"
            else
              echo "ğŸ“Š Testing all packages..."
              TEST_CMD="pnpm nx run-many -t test --all -c ci --parallel=4 --verbose"
            fi
            
            # First attempt with Nx Cloud (if enabled)
            set +e  # Don't exit on error - we'll handle it
            eval "$TEST_CMD" 2>&1 | tee /tmp/test-output.log
            TEST_EXIT=${PIPESTATUS[0]}
            set -e  # Re-enable exit on error
            
            # If command failed, check if it's Nx Cloud related
            if [ "$TEST_EXIT" -ne 0 ]; then
              # Check for any Nx Cloud related errors (quota, connection, auth, etc.)
              if grep -qiE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection.*failed|authentication.*failed|unauthorized|NX_CLOUD.*quota|rate.*limit.*exceeded|429.*Too Many Requests)" /tmp/test-output.log; then
                echo ""
                echo "âš ï¸  Nx Cloud error detected - disabling Nx Cloud and retrying..."
                echo "   Error details:"
                grep -iE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection|authentication|unauthorized|NX_CLOUD)" /tmp/test-output.log | head -5 || true
                echo ""
                echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
                export NX_SKIP_NX_CLOUD=true
                
                # Retry without Nx Cloud - this should succeed
                echo "ğŸ“Š Retrying test without Nx Cloud (using local cache only)..."
                set +e  # Don't exit on error for retry
                eval "$TEST_CMD"
                RETRY_EXIT=$?  # Capture exit code (no pipe in retry)
                set -e
                
                if [ "$RETRY_EXIT" -ne 0 ]; then
                  echo "âŒ Test failed even without Nx Cloud - this is a real error"
                  exit $RETRY_EXIT
                else
                  echo "âœ… Test succeeded without Nx Cloud"
                fi
              else
                # Not an Nx Cloud error - this is a real test error
                echo "âŒ Test failed with non-Nx Cloud error - exiting"
                exit $TEST_EXIT
              fi
            else
              echo "âœ… Test succeeded with Nx Cloud"
            fi
          }

          run_test
          
          # Cleanup temporary log files
          rm -f /tmp/test-output.log 2>/dev/null || true
        env:
          # Skip Nx Cloud if connection failed or token not set (falls back to local cache)
          NX_SKIP_NX_CLOUD: ${{ env.NX_SKIP_NX_CLOUD || 'false' }}

      - name: Build Affected Packages
        run: |
          export TSNODE_SKIP_TRANSPILATION=true

          # Function to run build with error handling for Nx Cloud failures
          run_build() {
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              echo "ğŸ”¨ Building affected packages..."
              BUILD_CMD="pnpm nx affected -t build --parallel=4 --verbose"
            else
              echo "ğŸ”¨ Building all packages..."
              BUILD_CMD="pnpm nx run-many -t build --all --parallel=4 --verbose"
            fi
            
            # First attempt with Nx Cloud (if enabled)
            set +e  # Don't exit on error - we'll handle it
            eval "$BUILD_CMD" 2>&1 | tee /tmp/build-output.log
            BUILD_EXIT=${PIPESTATUS[0]}
            set -e  # Re-enable exit on error
            
            # If command failed, check if it's Nx Cloud related
            if [ "$BUILD_EXIT" -ne 0 ]; then
              # Check for any Nx Cloud related errors (quota, connection, auth, etc.)
              if grep -qiE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection.*failed|authentication.*failed|unauthorized|NX_CLOUD.*quota|rate.*limit.*exceeded|429.*Too Many Requests)" /tmp/build-output.log; then
                echo ""
                echo "âš ï¸  Nx Cloud error detected - disabling Nx Cloud and retrying..."
                echo "   Error details:"
                grep -iE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection|authentication|unauthorized|NX_CLOUD)" /tmp/build-output.log | head -5 || true
                echo ""
                echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
                export NX_SKIP_NX_CLOUD=true
                
                # Retry without Nx Cloud - this should succeed
                echo "ğŸ”¨ Retrying build without Nx Cloud (using local cache only)..."
                set +e  # Don't exit on error for retry
                eval "$BUILD_CMD"
                RETRY_EXIT=$?  # Capture exit code (no pipe in retry)
                set -e
                
                if [ "$RETRY_EXIT" -ne 0 ]; then
                  echo "âŒ Build failed even without Nx Cloud - this is a real error"
                  exit $RETRY_EXIT
                else
                  echo "âœ… Build succeeded without Nx Cloud"
                fi
              else
                # Not an Nx Cloud error - this is a real build error
                echo "âŒ Build failed with non-Nx Cloud error - exiting"
                exit $BUILD_EXIT
              fi
            else
              echo "âœ… Build succeeded with Nx Cloud"
            fi
          }

          run_build
          
          # Cleanup temporary log files
          rm -f /tmp/build-output.log 2>/dev/null || true
        env:
          # Skip Nx Cloud if connection failed or token not set (falls back to local cache)
          NX_SKIP_NX_CLOUD: ${{ env.NX_SKIP_NX_CLOUD || 'false' }}

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # LAYER 6: RELEASE VALIDATION (Dry-run to catch release issues early)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # This step validates that a release would succeed without actually
      # making any changes. It catches issues like:
      # - No changes to release
      # - Invalid version calculations
      # - Build failures during preReleaseCommand
      # - Package version conflicts

      - name: ğŸ” Validate Release (Dry-Run)
        continue-on-error: false
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ” Release Validation (Dry-Run)"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "Running release dry-run to validate release process..."
          echo "This checks if a release would succeed without making any changes."
          echo ""

          # Function to run release validation with Nx Cloud error handling
          run_release_validation() {
            VALIDATION_CMD="pnpm nx release version --dry-run"
            
            # First attempt with Nx Cloud (if enabled)
            set +e  # Don't exit on error - we'll handle it
            RELEASE_OUTPUT=$(eval "$VALIDATION_CMD" 2>&1)
            RELEASE_EXIT_CODE=$?
            set -e  # Re-enable exit on error
            
            # If command failed, check if it's Nx Cloud related
            if [ "$RELEASE_EXIT_CODE" -ne 0 ]; then
              # Check for any Nx Cloud related errors (quota, connection, auth, etc.)
              if echo "$RELEASE_OUTPUT" | grep -qiE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection.*failed|authentication.*failed|unauthorized|NX_CLOUD.*quota|rate.*limit.*exceeded|429.*Too Many Requests)"; then
                echo ""
                echo "âš ï¸  Nx Cloud error detected - disabling Nx Cloud and retrying..."
                echo "   Error details:"
                echo "$RELEASE_OUTPUT" | grep -iE "(nx.?cloud|quota|rate limit|429|too many requests|exceeded|connection|authentication|unauthorized|NX_CLOUD)" | head -5 || true
                echo ""
                echo "NX_SKIP_NX_CLOUD=true" >> $GITHUB_ENV
                export NX_SKIP_NX_CLOUD=true
                
                # Retry without Nx Cloud - this should succeed
                echo "ğŸ“ Retrying release validation without Nx Cloud (using local cache only)..."
                set +e  # Don't exit on error for retry
                RELEASE_OUTPUT=$(eval "$VALIDATION_CMD" 2>&1)
                RELEASE_EXIT_CODE=$?
                set -e
                
                if [ "$RELEASE_EXIT_CODE" -ne 0 ]; then
                  # Not an Nx Cloud error - return for further handling
                  return $RELEASE_EXIT_CODE
                else
                  echo "âœ… Release validation succeeded without Nx Cloud"
                  return 0
                fi
              else
                # Not an Nx Cloud error - return for further handling
                return $RELEASE_EXIT_CODE
              fi
            else
              echo "âœ… Release validation succeeded with Nx Cloud"
              return 0
            fi
          }

          # Run release version dry-run (validates version calculation and preVersionCommand)
          echo "ğŸ“ Validating version calculation and preVersionCommand build..."
          run_release_validation
          RELEASE_EXIT_CODE=$?
          echo "$RELEASE_OUTPUT"

          # Check if there are changes to release (this is OK, not an error)
          if echo "$RELEASE_OUTPUT" | grep -q "No changes detected"; then
            echo ""
            echo "â„¹ï¸  No changes detected for release (this is OK for PRs)"
            echo "   This means there are no conventional commits since the last release."
            echo "   The release workflow would skip version bumping in this case."
            echo ""
            echo "âœ… Release validation passed (no changes to release)"
          elif [ -n "$RELEASE_EXIT_CODE" ] && [ "$RELEASE_EXIT_CODE" -ne 0 ]; then
            # Check if the error is about version range mismatch (common in PRs with old tags)
            # This happens when Nx resolves an old tag that conflicts with package.json
            # It's acceptable for PR validation since main branch will have correct tags
            if echo "$RELEASE_OUTPUT" | grep -q "preserveMatchingDependencyRanges.*outside the current range"; then
              echo ""
              echo "âš ï¸  Release validation warning: Version range mismatch detected"
              echo ""
              echo "This is expected for PR branches because:"
              echo "  - PR branch may not include commits where newer tags were created"
              echo "  - Nx's git-tag resolver only sees tags reachable from current HEAD"
              echo "  - Nx resolved an old tag version that conflicts with package.json"
              echo ""
              echo "âœ… This is acceptable for PR validation. The actual release on main will:"
              echo "  - Have access to all tags (tags are reachable from main)"
              echo "  - Resolve correct versions from git tags"
              echo "  - Work correctly with package.json dependencies"
              echo ""
              echo "âœ… Allowing PR to proceed (version resolution will be correct on main)"
            else
              echo ""
              echo "âŒ Release validation failed!"
              echo ""
              echo "This means the release workflow would fail. Common issues:"
              echo "  - Build failures during preVersionCommand"
              echo "  - Invalid version strategy"
              echo "  - Package version conflicts"
              echo "  - Git state issues"
              echo ""
              echo "Review the output above for details."
              exit 1
            fi
          else
            echo ""
            echo "âœ… Version calculation validated"
            echo ""
            echo "ğŸ“¦ Packages that would be released:"
            echo "$RELEASE_OUTPUT" | grep -E "(â†’|@forge-js|would be released)" || echo "$RELEASE_OUTPUT" | tail -20
            echo ""
            echo "âœ… Release validation passed!"
            echo "   The release workflow should succeed when run."
          fi

          # Note: We don't validate publish --dry-run here because:
          # 1. It requires version changes to already exist
          # 2. The preReleaseCommand build is already validated by the build step above
          # 3. NPM authentication and package conflicts are checked in the release workflow itself
          
          # Cleanup temporary log files
          rm -f /tmp/*-output.log /tmp/*-release-output.log 2>/dev/null || true
        env:
          # Skip Nx Cloud if connection failed or token not set (falls back to local cache)
          NX_SKIP_NX_CLOUD: ${{ env.NX_SKIP_NX_CLOUD || 'false' }}

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # LAYER 7: POST-TEST ACTIONS (DIAGNOSTICS)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      - name: Print CI diagnostics
        if: always()
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "CI Execution Summary"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "Trigger: ${{ github.event_name }}"
          echo "Branch: ${{ github.ref }}"
          echo "Environment: ${{ github.event_name == 'pull_request' && 'development' || 'staging' }}"
          echo ""
          echo "pnpm store status:"
          du -sh ~/.pnpm-store 2>/dev/null || echo "Not available"
          echo ""
          echo "Node version:"
          node --version
          echo ""
          echo "pnpm version:"
          pnpm --version
          echo ""
          echo "Nx Cloud status:"
          if [ "${{ env.NX_SKIP_NX_CLOUD }}" == "true" ]; then
            echo "  âš ï¸  Nx Cloud disabled (using local cache only)"
          else
            echo "  âœ… Nx Cloud enabled (if token configured)"
          fi
          echo ""
          pnpm nx report
